---
title: "Vari√°veis, Constantes e Convers√µes Aritm√©ticas"
description: "Neste cap√≠tulo, aprenderemos os basic types de dados e veremos como podemos us√°-los para declarar vari√°veis em nosso programa. √Ä medida que avan√ßamos para os pr√≥ximos cap√≠tulos, aprenderemos como construir composite types baseados nos basic types, como arrays e structures. Este cap√≠tulo tamb√©m discute convers√µes aritm√©ticas e vari√°veis constantes."
lead: "Neste cap√≠tulo, aprenderemos os basic types de dados e veremos como podemos us√°-los para declarar vari√°veis em nosso programa. √Ä medida que avan√ßamos para os pr√≥ximos cap√≠tulos, aprenderemos como construir composite types baseados nos basic types, como arrays e structures. Este cap√≠tulo tamb√©m discute convers√µes aritm√©ticas e vari√°veis constantes."
date: 2022-09-23T13:43:16-03:00
lastmod: 2022-09-23T13:43:16-03:00
draft: false
images: []
menu:
  docs:
    parent: ""
    identifier: "variables-5ed808dcc26868cb2b47f4c0908980e6"
weight: 200
toc: true
---

## Vari√°veis
____

A RAM do computador (Read Access Memory) consiste em milh√µes de c√©lulas de mem√≥ria sucessivas que s√£o usadas para armazenar dados. O tamanho de cada c√©lula √© um byte. Por exemplo, um PC com 8 GB (gigabytes) de RAM teria 8 √ó 1024 MB = 8 √ó 1024 √ó 1024 KB = 8 √ó 1024 √ó 1024 √ó 1,024 bytes = 8,589,934,592 c√©lulas de mem√≥ria.
Uma *vari√°vel* √© um local de mem√≥ria com um determinado nome (por exemplo, i). O valor de uma vari√°vel √© o conte√∫do de sua m√©moria de localiza√ß√£o (por exemplo, 10). Quando queremos acessar esse valor, usamos o nome da vari√°vel (por exemplo, i).

### Nomendo Vari√°veis

Existem algumas regras b√°sicas para nomear vari√°veis. Essas regras tamb√©m se aplicam aos nomes das functions. Certifique-se de segui-los ou seu c√≥digo n√£o compilar√°:

1. O nome ou o identificador pode conter letras, d√≠gitos e *caracteres underscore* _. O C++ n√£o define um limite no comprimento do nome.
2. O nome deve come√ßar com uma letra ou o caracteres underscore.
3. C++ √© *case sensitive*, o que significa que distingue entre letras mai√∫sculas e min√∫sculas. Por exemplo, a vari√°vel soma √© diferente das vari√°veis Sum ou sUM.
4. As keywords a seguir n√£o podem ser usadas como nomes de vari√°veis porque t√™m um significado especial para o compilador C++.

```s
and       const_cast      friend       or_eq         template     volatile
and_eq    continue        goto         private       this         wchar_t
asm       default         if           protected     throw        while
auto      delete          inline       public        true         xor
bitand    do              int          register      try          xor_eq
bitor     double          long         reinterpret_cast
bool      dynamic_cast    return       typedef
break     else            mutable      short         typeid
case      enum            namespace    signed        typename
catch     explicit        new          sizeof        union
char      extern          not          static        unsigned
class     false           not_eq       static_cast   using
compl     float           operator     struct        virtual
const     for             or           witch         void
```

O C++11 tamb√©m reserva as keywords a seguir:

```s
alignas  alignof  constexpr  char16_t  char32_t  decltype  noexcept  nullptr
static_assert  thread_local
```
Al√©m disso, a palavra __export__ √© reservada, enquanto as palavras __final__ e __override__ t√™m um significado especial, como veremos no Cap√≠tulo 20. A palavra __asm__ permite que o programador adicione c√≥digo escrito em linguagem assembly. Este livro explica o significado de cada keyword, exceto __thread_local__. S√≥ para saber, thread_local √© usado para declarar vari√°veis locais em threads. Este livro n√£o discute sobre este t√≥pico. Depois de ler um livro que descreve a Standard Template Library (STL), voc√™ aprender√° sobre programa√ß√£o multithread.

5. Para evitar conflitos de nomes, n√£o escolha nomes que comecem com um ou dois caracteres _, pois essas op√ß√µes s√£o reservadas para uso na biblioteca padr√£o. Al√©m disso, n√£o use nomes que o compilador usa, como nomes de fun√ß√µes de biblioteca ou vari√°veis (por exemplo, *cout*). Seu uso √© permitido, mas √© confuso e perigoso. Portanto, √© mais seguro lidar com nomes predefinidos como se fossem palavras reservadas.

Al√©m das regras fornecidas anteriormente, existem algumas conven√ß√µes que s√£o boas para seguir ao nomear suas vari√°veis. Embora n√£o sejam impostas pelo compilador, essas ‚Äúrules of thumb‚Äù tender√£o a tornar seus programas mais f√°ceis de entender, bem como para aqueles que precisam ler seu c√≥digo.

Use nomes descritivos para vari√°veis (claro, o mesmo se aplica a fun√ß√µes, tipos, ‚Ä¶). √â muito mais f√°cil ler um programa quando os nomes das vari√°veis indicam o uso pretendido. Por exemplo, se voc√™ usar uma vari√°vel que cont√©m a soma de alguns n√∫meros, d√™ a ela um nome como *sum* em vez de um nome irrelevante como i. Muitos programadores preferem usar letras min√∫sculas ao nomear vari√°veis e letras mai√∫sculas ao definir macros ou constantes. Nomes curtos (por exemplo, i) s√£o geralmente usados como √≠ndices em arrays ou loops. N√£o d√™ nomes a vari√°veis que sejam ligeiramente diferentes (por exemplo, *more* e *More*); √© muito f√°cil cometer um erro e usar uma vari√°vel no lugar da outra.

Quando necess√°rio, n√£o tenha medo de usar nomes longos para descrever o papel de uma vari√°vel. Se um nome de vari√°vel consiste em palavras, a pr√°tica usual √© separ√°-las com o caractere underscore _ para melhor legibilidade. Por exemplo, voc√™ pode chamar uma vari√°vel que cont√©m o n√∫mero de dias *days_number*, em vez de *daysnumber*, ou algo menos leg√≠vel. Em geral, seja qual for a abordagem escolhida, √© bom ser consistente e aplic√°-la ao longo do programa.

### Data Types

C++ fornece um conjunto de data types. Cada vari√°vel deve ter um type. O tipo determina a quantidade de mem√≥ria alocada para a vari√°vel, o intervalo de valores que podem ser atribu√≠dos a ela e o tipo de opera√ß√µes que podem ser aplicadas a ela. O tamanho dos tipos depende da implementa√ß√£o, ou seja, pode variar entre os diferentes sistemas. Os tipos de dados e seu tamanho usual em um sistema de 32 bits s√£o mostrados na Tabela 2.1.

C++11 adicionou os seguintes tipos:

__char16_t__: Usado para armazenar conjuntos de caracteres de 16-bits, como **UTF-16**.

__char32_t__: Usado para armazenar conjuntos de caracteres de 32-bits, como **UTF-32**.

__long long int__: Usado para integers muito grandes (pelo menos 64-bits). √â v√°lido que **sizeof(long)** <= **sizeof(long long int)**

{{< alert icon="üí°" text="O espa√ßo de mem√≥ria que um data type reserva pode variar de um sistema para outro. Por exemplo, o type __int__ pode reservar dois bytes em um embedded system ou um sistema mais antigo, quatro bytes ou oito bytes em um sistema moderno. Para saber o n√∫mero de bytes que um data type reserva em seu sistema, use o operador __sizeof__, conforme discutido no Cap√≠tulo 4."/>}}

**Tabela 2.1**

```
____________________________________________________________________________

Data Type          Tamanho usual (Bytes)          Faixa de Valores (Min-Max)  
____________________________________________________________________________
bool                       1                               false/true
char                       1                               ‚àí128 ‚Ä¶ 127
wchar_t                    2                            ‚àí32.768 ‚Ä¶ 32.767
short int                  2                            ‚àí32.768 ‚Ä¶ 32.767
int                        4                     ‚àí2.147.483.648‚Ä¶2.147.483.647
long int                   4                     ‚àí2.147.483.648‚Ä¶2.147.483.647
float                      4                O menor valor poss√≠vel: 1.17*10^-38
                                            O maior valor poss√≠vel: 3.4*10^38

double                     8                O menor valor poss√≠vel: 2.2*10^‚àí308
                                            O maior valor poss√≠vel: 1.8*10^308
long double              12, 16
unsigned char              1                                0 ‚Ä¶ 255
unsigned short int         2                               0 ‚Ä¶ 65535
unsigned int               4                            0 ‚Ä¶ 4.294.967.295
unsigned long int          4                            0 ‚Ä¶ 4.294.967.295

```

Os tipos __char__, __short__, __int__ e __long__ s√£o usados para armazenar valores integer, que podem ser signed or unsigned. Se adicionarmos a palavra __unsigned__ a vari√°vel n√£o possui sign bit e pode armazenar apenas valores positivos ou zero. A palavra __int__ pode ser omitida, por exemplo, __long__ em vez de __long int__. Al√©m disso, as palavras podem ser misturadas em qualquer ordem, por exemplo, a declara√ß√£o __unsigned long int__ a; √© o mesmo que __int long unsigned__ a;.

Com exce√ß√£o do tipo __char__, todos os outros tipos s√£o signed por padr√£o. Nos signed types, o bit mais √† esquerda √© reservado para o sign. Se o n√∫mero for negativo, seu valor √© 1, caso contr√°rio 0. A vantagem de __unsigned__ types √© que eles t√™m um limite superior mais alto do que seus equivalentes signed, pois n√£o precisam contabilizar valores negativos.

Os caracteres s√£o representados por c√≥digos num√©ricos espec√≠ficos. O tipo char √© normalmente usado para armazenar os c√≥digos num√©ricos dos caracteres do conjunto b√°sico, como o conjunto ASCII (por exemplo, ele inclui caracteres que aparecem no teclado, como d√≠gitos, letras, sinais de pontua√ß√£o, ‚Ä¶). O tipo __wchar_t__ √© usado para armazenar os c√≥digos num√©ricos dos caracteres de um conjunto maior, como o Unicode.

O tipo char pode ser signed ou unsigned, depende da implementa√ß√£o. Portanto, se for importante para o seu programa, voc√™ deve escrever explicitamente __char signed__ ou __char unsigned__ em vez de __char__. Por exemplo, se escrevermos: 

```c++
char a = 255;
int b = a;
```
o valor de b n√£o est√° especificado. Em um sistema onde o tipo __char__ √© signed b torna-se -1, enquanto em outro onde o tipo __char__ √© unsigned b torna-se 255.

O tipo __bool__ tem dois valores poss√≠veis, __true__ e __false__. O literal __true__ √© convertido em 1 quando convertido em um valor e __false__ em 0. Por outro lado, valores diferentes de zero s√£o convertidos em __true__, enquanto um valor zero √© convertido em __false__. Por exemplo:

```c++
bool b = 2; // b torna-se true.
int i = false; // i torna-se 0.
```
Normalmente, uma vari√°vel **bool** √© usada para armazenar o resultado de uma a√ß√£o, como se um valor √© encontrado em uma array ou n√£o.

Os tipos __float__, __double__ e __long double__ s√£o usados para armazenar valores com uma parte fracion√°ria, ou seja, n√∫meros floating-point. Ao contr√°rio dos integer types, os floating-point s√£o sempre signed. Embora o tipo __long double__ normalmente forne√ßa a mais alta precis√£o, raramente √© usado porque a precis√£o dos tipos __float__ e __double__ geralmente √© suficiente. 

Embora o C++ permita que cada implementa√ß√£o defina seus pr√≥prios tamanhos para os data types, ele imp√µe algumas restri√ß√µes aos seus tamanhos m√≠nimos. Especificamente, o tamanho do tipo __char__ deve ser de pelo menos 8 bits, o tamanho do __short__ pelo menos 16 bits e o tamanho do __int__ pelo menos igual ao do __short__. O tamanho do tipo __long__ deve ser de pelo menos 32 bits e pelo menos igual ao do tipo __int__. A seguinte ordem se aplica: __sizeof(char)__ <= __sizeof(short)__ <= __sizeof(int)__ <= __sizeof(long)__. O tamanho do tipo __wchar_t__ depende da implementa√ß√£o; no entanto, aplica-se: __sizeof(char)__ <= __sizeof(wchar_t)__ <= __sizeof(long)__. Se for importante economizar mem√≥ria e os valores se ajustarem, use __short__ ao inv√©s de __int__, pois seu tamanho geralmente √© menor. Um exemplo t√≠pico √© quando voc√™ tem uma grande matriz de integers.

Para os tipos floating-point, C++ especifica que o tamanho do tipo __long double__ deve ser pelo menos igual ao do __double__, e o tamanho do tipo __double__ deve ser pelo menos igual ao do __float__. Se voc√™ quiser aprender os tamanhos dos tipos integer e floating-point que seu sistema suporta, use o operador __sizeof__. Se voc√™ quiser saber mais sobre os type limits, leia os arquivos de cabe√ßalho *climits* e *cflat*. Al√©m disso, voc√™ pode usar o arquivo de cabe√ßalho de *limits* e obter informa√ß√µes de type. Por exemplo, o proximo statement exibe o valor m√°ximo do tipo __int__:

```c++
std::cout << "O valor m√°ximo do tipo int √©: " << std::numeric_limits<int>::max();
```

Para obter o valor m√≠nimo, substitu√≠mos max() por min(). Se voc√™ deseja obter os valores m√°ximos para outros data types, substitua o tipo int nos colchetes angulares(angled brackets) pelo tipo desejado.

{{< alert icon="üí°" text="Se voc√™ n√£o se importa com a precis√£o use o tipo __float__, pois normalmente ele reserva menos bytes e c√°lculos com n√∫meros float tendem a ser executados mais rapidamente."/>}}

Vamos executar o seguinte programa. O operador == na instru√ß√£o __if__ compara o valor de *a* contra 3.1. O que voc√™ acha que o programa exibir√°, Sim ou N√£o?

```c++
#include <iostream> // Example 2.1.
int main()
{
  float a = 3.1;
  if(a == 3.1)
    std::cout << "Sim\n";
  else
    std::cout << "N√£o\n";
  return 0;
}
```
Embora a resposta √≥bvia seja Sim, o programa gerou N√£o ? Surpresa! E o motivo se deve √† capacidade limitada do tipo __float__ para representar precisamente o n√∫mero 3.1. Como veremos mais tarde, por padr√£o, o tipo de uma floating constant (por exemplo, 3.1) √© __double__.



